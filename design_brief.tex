\documentclass{cce2014-design}
\svnInfo $Id$

% Document details
\title{Design Brief: Group 5}
\author{
   Akram Sharara,
   Antoni Marek Skoć,
   Daniel Agius}
\date{March 13, 2025, Document v.1}

\usepackage{graphicx}

\begin{document}

\maketitle

\abstract{%
Abstract

As a record of the development of the Morse code receiver, this initial design brief provides an outline of the aims and objectives of the project as set out in the handbook and how they will be realized. It discusses a comprehensive view of the development stages of the receiver using Fig. 1 and how signal sampling will be handled to convert analog audio inputs to digital ones. Finally, it explores how current code implementations will use this data to translate Morse code to characters using a binary tree, in addition to functions that could provide a clear approach to scheduling and displaying the outputs on an LCD. A timeline is provided to document management of ongoing work as well as areas of focus. Although the timeline is flexible, work distribution is clear among members and a prototype receiver is expected to be prepared around Easter.
   }

\section{Introduction}
The objective of this assignment is to design and implement a microcontroller-based system that receives an input Amplitude Shift Keyed (ASK) Morse code signal, translates it into characters, and displays it on an LCD. Additionally, our implementation of the Morse code translator may take into consideration the possible presence of noise in the signal, as well as adapt to different transmission speeds. All code will be written in C/C++. 

\section{System Design}
\subsection{General Design}
The initial design plan will follow the outline shown in figure 1. Initially, the audio input is taken by the receiver as an analogue sinusoidal tone of a defined frequency. Once this signal is sampled, it can then be converted from an ASK signal to a digital signal. Using a binary tree, this can then be decoded to a particular character to be displayed on the LCD using the necessary display functions.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\textwidth]{Untitled_Diagram.drawio.png}
    \caption{diagram outlining the development of the Morse code receiver.}
    \label{fig:morse_tree}
\end{figure}

\subsection{Signal Sampling and Conversion to a Digital Signal}
The sampling and demodulation part is responsible for converting the amplitude shift keyed waveform into a binary high or low internal output, which is necessary for conversion into dots and dashes. The intended implementation for this mainly involves sampling and digital conversion. For sampling, the receiver will use the analogue pins of the microcontroller to sample every T time and save the contents to a queue. There are many ways to protect the analogue pin from overvoltage, namely the presence of a 3.3 V zener or TVS diode in parallel with the output and some biasing resistors in the case the voltage needs to be stepped down.

As for digital conversion, to determine the presence of the ASK signal, a Fourier transform algorithm on the queue of analogue values is to be used. While the specific algorithm is to be determined, there is no way around using it. The presence of the frequency used in the ASK signal at a reasonable magnitude will be considered as a 1, and the lack of it, a 0. This value will be passed to the next code responsible for Morse code translation.

To determine if the signal is high or low for a whole unit time T, either a timer or counter based function will be used. This is to prevent sporadic short pulses from affecting the signal, and also to allow changing of the unit time.
\subsection{Morse Code Translation}

Due to the binary nature of Morse code, it allows the use of a binary tree structure where each node is reachable through a dot or a dash. As seen in the Morse code document \cite{itu2009}, it is intuitive that a tree of characters that are reachable using dot and dash traversals would allow for fast lookup and efficient memory usage due to the compact nature of characters, which are stored as 8 bit integers. A simplified binary tree which does not include all necessary symbols is shown in Figure 2 \cite{morsecode-tree}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\textwidth]{Morse-code-tree.png}
    \caption{Morse Code Binary Tree.}
    \label{fig:morse_tree}
\end{figure}

Our implementation would extend this tree to include traversals to nodes that map to all characters or signals in the Morse code document. The tree begins in a stable start state, then as it receives either a dot of a dash, it traverses down by a depth of 1, reaching either “E” (.) or “T” (-), and continues throughout. Therefore, a consecutive sequence of 5 dots (.....) would map to “5” in Morse code, the left most node, whereas 5 consecutive dashes (-----) would map to “0” in Morse code, the right most node. This implementation allows for fast lookup, because traversing a binary tree takes place in O(log$_2$ n) time. 

Additionally, given the Morse code receiver receives signals sequentially, traversal would immediately decode the characters, eliminating complex comparisons that would be necessary for other implementations, such as a list or an array. The full implementation would be able to reach any character in at most 6 steps, with one 8-step node that denotes an error, which can be used for error handling, and is 8 dots according to the document.

The microcontroller will receive signals and based on a defined unit length, will determine if it is a dot of unit length or a dash of 3 unit lengths, and decode the signal using the tree.
\subsection{LCD Display}
To display the translated morse signal on the LCD, predefined functions from Lab 4 will be used. Functions such as \textit{lcd\_write\_data}, \textit{lcd\_put\_char}, and \textit{lcd\_print} allow us to project our Morse code translations to the LCD screen. The \textit{lcd\_put\_char} function is responsible for displaying individual characters, while \textit{lcd\_print} allows for printing entire strings. The functions use a serial-to-parallel shift register on the LPC microcontroller, minimizing the number of pins needed to 3 GPIO pins. This approach optimizes hardware resource usage while maintaining efficient data communication with the LCD module. The functions in \textit{lcd.c} send data to the LCD in 4-bit mode, meaning any 8-bit character is split into 2 4-bit chunks before being sent to the LCD. 

\subsection{Scheduling}

As all functions depend on data provided by previous functions, out of order execution is inevitable to have a remotely efficient implementation. Thus, it is best that when a function finishes execution and generates new data (e.g. digital conversion) an interrupt is raised for the next function (Morse code translation) to run. Most functions aren’t time critical and thus do not need high priority, except sampling, where the time between samples must be equal. Thus, if a sample is needed, it takes precedence.

\section{Management}
Based on Fig. 1, digital to char has a robust implementation regarding the Morse code binary tree, but an implementation to hide spaces is not yet finalized. However, this allows for dedicating more time to intensive stages, namely the analog to digital input conversion stage. Although the rest of the code still needs to be constructed, code at every stage will be designed with modularity in mind. It is important to note that the digital to char stage depends on the previous sampling and ASK to digital conversion stages. 

The ASK to digital conversion stage is expected to be the most laborious, given sampling and digital to char conversion are relatively simple. Therefore, the current timeline will focus on implementing all four stages represented in Fig. 1 in parallel, with a higher consideration for the analog to digital stage, with a fully fledged implementation expected around Easter. Finally, all functionalities will be seamlessly integrated using scheduling algorithms. This will take place within the final phases of development. 

Because different stages require different skills, task distribution is accorded based on proficiency and capability in the given task, but it is important to note that each member will participate in an active role at all stages of development. The sampling stage will be distributed to Daniel based on his computer engineering capabilities. The digital conversion stage will be handled by all members as it seems to be the most challenging. Akram shall implement the Morse code translation via a binary tree for the digital to char conversion, whereas Antoni will be focused on integrating the LCD functionality with the underlying logic and hardware to provide accurate representations of outputs in accordance with the Morse code document standards.

The documentation for each stage in this brief and for any code will be written by the respective members and each subsequent record of development for specific stages will be written by the assigned members. Unit tests will be developed for code at each stage.


\section{Closure}
The development of the Morse code receiver is structured into distinct stages, each focusing on critical aspects such as signal sampling, digital conversion, Morse code translation, and LCD display. By leveraging efficient algorithms, such as the binary tree traversal for Morse code decoding, and optimizing hardware usage with a serial-to-parallel shift register, the system is designed to be both robust and scalable.

Moving forward, the primary focus will be on finalizing the implementation of signal sampling and ASK-to-digital conversion, as these form the foundation for the entire decoding process. Task scheduling will be refined to ensure seamless communication between system components, and performance testing will be conducted to assess accuracy, noise resilience, and response time.

With a structured timeline and clear task distribution, the project is expected to progress efficiently toward the development of a functional Morse code receiver. The final implementation will be evaluated based on performance metrics, and necessary optimizations will be made to ensure reliability in real-world conditions.



\bibliographystyle{ieeetr}
\bibliography{references}

\begin{bibliography}

\end{bibliography}

\end{document}
